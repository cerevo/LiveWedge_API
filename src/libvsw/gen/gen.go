// Copyright 2015, Cerevo Inc. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"fmt"
	"log"
	"os"
)

const head = `// This file is auto-generated by gen.go. Do not edit.

package libvsw

import (
	"bytes"
	"encoding/binary"
	"log"
	"unsafe"
)
`

const fa = `
var (
	%[1]s %[1]sType
	_%[1]sChan chan %[1]sType
)

// Request%[1]s gets chan for beging notifyed %[1]s changed.
func (vsw Vsw) Request%[1]s() <-chan %[1]sType {
	if _%[1]sChan == nil {
		_%[1]sChan = make(chan %[1]sType)
	}
	return _%[1]sChan
}

func read%[1]s(len int, reader *bytes.Reader) {
	var a %[1]sType
	if len != int(unsafe.Sizeof(a)) {
		log.Printf(" size mismatch %%T len=%%d\n", a, len)
		return
	}
	err := binary.Read(reader, _LE, &a)
	checkError(err)
	if %[1]s != a {
		//log.Printf("%%#v\n", a)
		%[1]s = a
	        if _%[1]sChan != nil {
		       _%[1]sChan <- a
	        }
	}
}
`

func main() {
	a := []string{
		"SwMode",
		"DefaultBackgroundColor",
		"MountStatus",
		"PreviewMode",
		"RecordingStatus",
		"FadeToDefaultColorStatus",
		"ExternalInputStatus",
		"ProgramOutStatus",
		"PreviewOutStatus",
		"CasterMessage",
		"CasterStatistics",
		"SwitcherStatus",
		"AudioMixerStatus",
		"AudioMixerAllStatus",
		"AudioPeakStatus",
		"RecordingResult",
		//"LiveBroadcastResult",
		"SubMode",
		"PinpGeometry",
		"PinpBorder",
		"ChromaRange",
	}

	file, err := os.Create("generated.go")
	if err != nil {
		log.Fatal(err)
	}
	defer file.Close()
	fmt.Fprint(file, head)
	for _, v := range a {
		fmt.Fprintf(file, fa, v)
	}
}
